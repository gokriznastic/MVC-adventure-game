package controller;

import java.io.InputStreamReader;
import java.util.Objects;
import java.util.Random;
import javax.swing.JOptionPane;

import model.AdventureGameModel;
import model.Direction;
import model.GameModel;
import model.Treasure;
import model.Weapon;
import utils.Randomizer;
import view.GameView;
import view.GuiGameView;
import view.NewInputView;

/**
 * The class representing GUI controller for the dungeon adventure game.
 * This class provides features for the GUI, captures event callbacks, creates model,
 * creates the view and responds to any events generated by the view.
 */
public class GuiGameController implements GuiGameFeatures {
  private GameModel model;
  private GameView view;
  private String[] args;

  /**
   * Default constructor for the GUI controller. It inflates a 'enter dungeon paramaters'
   * input dialog and uses the user given parameters to create the model and view
   * and start the game.
   */
  public GuiGameController() {
    this.args = new NewInputView().getDungeonParams();

    this.run();
  }

  /**
   * Constructor for GUI controller where the model and view are constructed beforehand and passed.
   *
   * @param m the model
   * @param v the view
   */
  public GuiGameController(GameModel m, GameView v) {
    this.model = m;
    this.view = v;
  }

  private void run() {
    this.model = createNewModel(this.args);

    if (this.args[this.args.length - 1].equals("console")) {
      this.runConsoleBasedGame();
    } else {
      this.runGraphicsBasedGame();
    }
  }

  private void runConsoleBasedGame() {
    Readable input = new InputStreamReader(System.in);
    Appendable output = System.out;

    GameController controller;

    try {
      Objects.requireNonNull(this.model);
    } catch (NullPointerException npe) {
      throw new IllegalArgumentException("Model cannot be null");
    }

    controller = new TextBasedGameController(input, output, this.model);
    controller.playGame();
  }

  private void runGraphicsBasedGame() {
    if (!Objects.isNull(this.model)) {
      this.view = new GuiGameView(this.model);
    } else {
      this.restartGame();
    }

    this.playGame();
  }

  @Override
  public void playGame() {
    this.setView();
  }

  private void setView() {
    this.view.setFeatures(this);
    this.view.resetFocus();
  }

  @Override
  public void move(int direction) {
    try {
      if (direction == 0) {
        this.model.movePlayer(Direction.NORTH);
      } else if (direction == 1) {
        this.model.movePlayer(Direction.SOUTH);
      } else if (direction == 2) {
        this.model.movePlayer(Direction.EAST);
      } else if (direction == 3) {
        this.model.movePlayer(Direction.WEST);
      }

      this.view.refresh();
    } catch (IllegalArgumentException iae) {
      // do nothing
    }

    if (this.model.isGameOver()) {
      if (this.model.getPlayer().isAlive()) {
        this.view.showMessage("Bravo! Player wins!",
                "Game Over!", JOptionPane.PLAIN_MESSAGE);
      } else {
        this.view.showMessage("Chomp, chomp, chomp, player is eaten by an un-slayed Otyugh!",
                "Game Over!", JOptionPane.PLAIN_MESSAGE);
      }

      this.view.refresh();
    }
  }

  @Override
  public void pick(int item) {
    try {
      if (item == 0) {
        this.model.pickItem(Weapon.ARROW);
      } else if (item == 1) {
        this.model.pickItem(Treasure.DIAMOND);
      } else if (item == 2) {
        this.model.pickItem(Treasure.RUBY);
      } else if (item == 3) {
        this.model.pickItem(Treasure.SAPPHIRE);
      }

      this.view.refresh();
    } catch (IllegalArgumentException iae) {
      this.view.showMessage(iae.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
    }

  }

  @Override
  public void shoot(int direction, String distance) {
    if (distance != null && !distance.trim().equals("")) {
      int dist;
      try {
        dist = Integer.parseInt(distance);
      } catch (NumberFormatException nfe) {
        this.view.showMessage("Invalid distance - " + distance,
                "Error", JOptionPane.ERROR_MESSAGE);
        return;
      }

      try {
        if (direction == 0) {
          this.model.shootArrow(Direction.NORTH, dist);
        } else if (direction == 1) {
          this.model.shootArrow(Direction.SOUTH, dist);
        } else if (direction == 2) {
          this.model.shootArrow(Direction.EAST, dist);
        } else if (direction == 3) {
          this.model.shootArrow(Direction.WEST, dist);
        }

        this.view.refresh();
      } catch (IllegalArgumentException | IllegalStateException e) {
        this.view.showMessage(e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
      }
    }
  }

  @Override
  public void resetGame() {
    this.view.delete();

    this.model = createNewModel(this.args);
    this.view = new GuiGameView(this.model);

    this.setView();
  }

  @Override
  public void restartGame() {
    this.view.delete();

    this.args = new NewInputView().getDungeonParams();

    this.model = createNewModel(this.args);
    this.view = new GuiGameView(this.model);

    this.setView();
  }

  @Override
  public void quitGame() {
    System.exit(0);
  }

  @Override
  public void handleCellClick(int clickedX, int clickedY, int playerX, int playerY) {
    int direction = getDirection(playerX, playerY, clickedX, clickedY);

    if (direction >= 0) {
      this.move(direction);
    }
  }

  private int getDirection(int xOne, int yOne, int xTwo, int yTwo) {
    int rows = this.model.getDungeon().getDungeonGrid().length;
    int cols = this.model.getDungeon().getDungeonGrid()[0].length;

    if ((xTwo - xOne) == -1 && (yTwo - yOne) == 0) {
      return 0;
    } else if ((yTwo - yOne) == 1 && (xTwo - xOne) == 0) {
      return 2;
    } else if ((xTwo - xOne) == 1 && (yTwo - yOne) == 0) {
      return 1;
    } else if ((yTwo - yOne) == -1 && (xTwo - xOne) == 0) {
      return 3;
    } else if ((xTwo - xOne) == (rows - 1) && (yTwo - yOne) == 0) {
      return 0;
    } else if ((yOne - yTwo) == (cols - 1) && (xTwo - xOne) == 0) {
      return 2;
    } else if ((xOne - xTwo) == (rows - 1) && (yTwo - yOne) == 0) {
      return 1;
    } else if ((yTwo - yOne) == (cols - 1) && (xTwo - xOne) == 0) {
      return 3;
    } else {
      return -1;
    }
  }

  private GameModel createNewModel(String[] args) {
    // parse args
    int rows;
    int cols;
    int interconn;
    int percent;
    int difficulty;
    boolean wrap;

    try {
      rows = Integer.parseInt(args[0]);
      cols = Integer.parseInt(args[1]);
      wrap = Boolean.parseBoolean(args[2]);
      interconn = Integer.parseInt(args[3]);
      percent = Integer.parseInt(args[4]);
      difficulty = Integer.parseInt(args[5]);
    } catch (NumberFormatException nfe) {
      throw new IllegalArgumentException("Unable to parse dungeon arguments, "
              + "please check and try again");
    }

    Random rand = new Randomizer(42).getRandom();
    GameModel newModel;

    try {
      newModel = new AdventureGameModel(rand, rows, cols, wrap, interconn, percent, difficulty);
    } catch (IllegalStateException | IllegalArgumentException e) {
      throw new IllegalArgumentException(e.getMessage());
    }

    return newModel;
  }
}
